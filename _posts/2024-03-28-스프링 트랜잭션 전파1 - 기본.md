스프링 트랜잭션 전파1 – 커밋 , 롤백
- 트랜잭션이 둘 이상 있을 때 어떻게 동작하는지 자세히 알아보고 스프링이 제공하는 트랜잭션 전파(propagation) 라는 개념도 알아볼 것임
- 트랜잭션 전파를 이해하는 과정을 통해 스프링 트랜잭션의 동작 원리도 더 깊이있게 이해할 수 있을 것임
- 트랜잭션 사용 중에 또 트랜잭션 사용하는 경우 알아볼 것 ㅇㅇ

TransactionStatus
- 트랜잭션 매니저로 트랜잭션 시작 시 트랜잭션 상태 코드가 반환됨
- 해당 상태 코드를 파라메터로 넘겨서 rollback() , commit 수행 가능



스프링 트랜잭션 전파2 – 트랜잭션 두 번 사용
- 트랜잭션1시작 => 트랜잭션1 커밋 => 트랜잭션2 시작 => 트랜잭션2 커밋
- 트랜잭션1을 시작하고 커넥션 풀에서 conn0 획득 , 커밋 시 conn0반납 => 트랜잭션2를 시작하고 커넥션 풀에서 conn0 획득 , 커밋 시 conn0 반납

주의 : 같은 물리적 커넥션이지만 다른 커넥션 연결
- 트랜잭션 1,2가 같은 conn0 커넥션을 사용
- 이건 한 히카리 커넥션 풀에서 사용됐기 때문이지 같은 커넥션을 유지하는 게 아니다. 그냥 1이 쓰고 제자리에 반납했으니 2가 제일 첫번째 커넥션인 conn0을 다시 커넥션 연결하는데 쓰인 것!
 물리적인 커넥션은 갖지만 완전 다른 커넥션(세션)임
 즉 같은 커넥션이 쓰인 것은 맞지만 1이 완전히 반납하고 2가 새로 커넥션을 할당받은 것

물리적으로 같은 커넥션의 둘의 구분
- 커넥션 풀에서 커넥션 획득 시 실제 커넥션을 그대로 반환하는 게 아닌 내부 관리를 위해 히카리 프록시 커넥션이라는 객체를 생성해서 반환
- 해당 객체 내부에는 실제 커넥션이 포함됨
- 해당 객체의 주소를 확인하면 아무리 물리적으로 같은 커넥션이더라도 주소가 다르니 구분할 수 있음
 
 - 즉 한 커넥션 풀에서 커넥션을 할당받았으니 물리적으로 같은 커넥션이 쓰인 거고 실질적으론 서로 다른 커넥션이라 보면 됨
 DriverManager이었으면 아예 새로운 커넥션을 생성해서 할당해줄 것임
기본적인 커넥션의 생성 제거 흐름
 
 이런 식으로 디폴트는 커넥션이 db로부터 새로 생성됐다가 트랜잭션 종료(커밋 , 롤백) 시점에 제거되고 새롭게 트랜잭션을 다른 곳에서 시작할 땐 새로운 커넥션을 생성해서 반환해줌
 커넥션 풀이어서 같은 커넥션을 쓴 것!

결론
- 각각의 트랜잭션에서 커넥션 할당받으면 서로 다른 커넥션이다
- 커넥션 풀에서 커넥션을 쓰면 같아보이지만 실질적으론 이미 트랜잭션1에서 사용이 끝나고 반환한 커넥션을 트랜잭션2에서 사용하는 것!

스프링 트랜잭션 전파3 – 전파 기본
- 트랜잭션을 각각 사용하는 게 아닌 트랜잭션이 이미 진행 중인데 그 안에서 트랜잭션을 또 수행하면 어떻게 될까
- 기존 트랜잭션과 별도의 트랜잭션을 진행해야 할까 아니면 기존 트랜잭션을 그대로 이어받아서 트랜잭션을 수행해야될까
- 이런 경우 어떻게 동작할지 결정하는 것을 트랜잭션 전파(propagation)라고 함


 

